---
layout: post
permalink: /blog/computer-network/
date:   10.12.2016
categories: Global
tags: [development, ip, dns, http]
title: Компьютерные сети. Основной принцип работы
---

<p> <b>Компьютерная сеть (Computer Network)</b> – это множество компьютеров, соединенных линиями связи и работающих под
    управлением специального программного обеспечения.
</p>
<p> В первую очередь нам нужно познакомиться с <a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank">сетевой моделью
    <strong>OSI</strong></a> ( open systems interconnection basic reference model). Эта модель стандартизирует
    взаимодействие сетевых протоколов.<br/>
    OSI делит коммуникацию на 7 слоёв, на каждом слое есть свои протоколы. Ты часто будешь слышать вещи в духе "это
    происходит на Layer 3". Вот эти слои:<br/>
    <ol>
        <li>Физический уровень (physical layer)&nbsp;</li>
        <li>Канальный уровень (data link layer)</li>
        <li>Сетевой уровень (network layer)</li>
        <li>Транспортный уровень (transport layer)</li>
        <li>Сеансовый уровень (session layer)</li>
        <li>Представительский уровень или уровень представления (presentation layer)</li>
        <li>Прикладной уровень (application layer)</li>
    </ol>
</p>
<h2> 1. Физический уровень </h2>
    Cвязь между железками на самом низком уровне, как по проводам так и без (Wifi, Bluetooth).<br/>
    <p> Физический уровень описывает способы передачи бит (а не пакетов данных) через физические среды линий связи,
        соединяющие сетевые устройства. На этом уровне описываются параметры сигналов, такие как амплитуда и частота,
        используемая модуляция и другие низкоуровневые параметры.
    </p>


<h2> 2. Канальный уровень </h2>
<p>
    Обеспечивает передачу данных между железками. Данные как фреймы, в котором указан физический адрес получателя и
    отправителя (MAC-адрес, прошитые в железке NIC - network interface controller).

</p>
    <table>
        <tbody>
        <tr>
            <td>
                <a href="https://lh6.googleusercontent.com/lBN406PUdHIVh1-7hW8yn3D-XMIorbVXVVahrrjPtQewOvG1i-ViJPBFLqFY6R8F5IeN7gfVXNbZS48y6tC1uFJfh9v4bdrO1VLslB9lNeavjXrre_5OoWZ32MFU86ELUnMh9wqE">
                    <img src="https://lh6.googleusercontent.com/lBN406PUdHIVh1-7hW8yn3D-XMIorbVXVVahrrjPtQewOvG1i-ViJPBFLqFY6R8F5IeN7gfVXNbZS48y6tC1uFJfh9v4bdrO1VLslB9lNeavjXrre_5OoWZ32MFU86ELUnMh9wqE"
                        width="200" height="112"/></a></td>
        </tr>
        <tr>
            <td>Пример свитча</td>
        </tr>
        </tbody>
    </table>
<br/>
    <p><strong>Свитч</strong> - устройство, которое формирует сеть и в которое подключаются через порты машины. &nbsp;Задача
    свитча - это перенаправлять кадры MAC отправителя к MAC получателя. Множество машин, подключенных к одному свитчу
    формируют <a href="https://en.wikipedia.org/wiki/Local_area_network"><strong>локальную сеть</strong> (LAN)</a>.<br/>
    Более старое поколение - это так называемые <strong>хабы</strong> (hub). Работает намного медленнее, так как данные
    будут проходить через все компьютерные сети. Соответственно, чем больше компьютеров подключено, тем медленее будет
    соединения и больше нагрузка на сеть.</p>

<p><b>А что если сеть в разных локациях?</b></p>
<p> Для таких случаев создают <strong>VLAN</strong> (виртуальную локальную сеть), которую можно реализовать, например,
    при помощи свитча. &nbsp;Работает это достаточно просто: к кадрам добавляется дополнительный заголовок с VLAN-тегом,
    по которому и определяется к какой сети принадлежит кадр.</p>


<p>
    <table>
        <tbody>
        <tr>
            <td>
                <a href="https://lh5.googleusercontent.com/9yKwdQXhsQD7993d0jpf-gd-WWntJLX3jsV51pMtR6fCVv9dSFPeQKPwxg3RrKS422N-LuHpQ9pnC0pyqcInMgvhRMpYHv9Uo9-Tu5F9qITfkKW1LxjpdoFj_doo-S3sPZUyY5PJ">
                    <img src="https://lh5.googleusercontent.com/9yKwdQXhsQD7993d0jpf-gd-WWntJLX3jsV51pMtR6fCVv9dSFPeQKPwxg3RrKS422N-LuHpQ9pnC0pyqcInMgvhRMpYHv9Uo9-Tu5F9qITfkKW1LxjpdoFj_doo-S3sPZUyY5PJ"
                        width="200" height="112"/></a></td>
        </tr>
        <tr>
            <td>Пример VLAN</td>
        </tr>
        </tbody>
    </table>
    <p>Другое устройство — мост. Мост L2 используют чтобы объединить две сети, сформированные при помощи свитчей.<br/></p>
    <table>
        <tbody>
        <tr>
            <td>
                <a href="https://lh6.googleusercontent.com/J5J902kiLMYrGYr9W4CXE2kLiXvvk_n4sP6rngdxuejz5U9zJymE2I9VU4nRr59-zq3yD4wwso4Cf2Wfz2wzlgXOpSA4JJCfIEc8F2-2hoR04l12wVMkjZiFVOd8ZAIJJkGoBfRm">
                    <img src="https://lh6.googleusercontent.com/J5J902kiLMYrGYr9W4CXE2kLiXvvk_n4sP6rngdxuejz5U9zJymE2I9VU4nRr59-zq3yD4wwso4Cf2Wfz2wzlgXOpSA4JJCfIEc8F2-2hoR04l12wVMkjZiFVOd8ZAIJJkGoBfRm"
                        width="200" height="112"/></a></td>
        </tr>
        <tr>
            <td>Пример моста</td>
        </tr>
        </tbody>
    </table>
    <br/>
    <h2>3. Сетевой уровень </h2>
    <p>Используются IP адреса для идентификации компьютерного устройства в сети.</p>

<p> Но как именно у сетевого интерфейса появляется IP адрес? &nbsp;Либо задается в ручную по определенному алгоритму,
    либо через Dynamic Host Configuration Protocol (<a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol"><strong>DHCP</strong></a>),
    протокол, использующийся для автоматического выставления различной конфигурации, в том числе IP-адресов. Для работы
    DHCP нужен DHCP-сервер, раздающий IP-адреса и DHCP-клиент на твоей машине, который будет запрашивать адрес для этой
    машины. В домашних условиях чаще всего DHCP-сервер находится на роутере.
</p>
<p> Чтобы понять как именно работает DHCP, нам нужно отвлечься на понятие "broadcasting". Это процесс, в котором наш
    сервер отправляет сообщение на все сервера в сети, так как он не знает где именно находится та информация, которая
    ему нужна. Ближе всего такое broadcast общение к радио вещанию.Как это происходит в случае с DHCP: </p>
    <ul>
        <li>DHCP-клиент отправляет broadcast сообщение с вопросом "Хочу IP адрес"&nbsp;</li>

        <li>DHCP-сервер его ловит и в ответ отправляет так же broadcast сообщение "У меня есть адрес x.x.x.x, хочешь
            его?"&nbsp;</li>

        <li>DHCP-клиент получает это сообщение и отправляет ещё одно: "Да, я хочу адрес x.x.x.x"</li>

        <li>DHCP-сервер отвечает "Хорошо, тогда x.x.x.x принадлежит тебе"&nbsp;</li>
    </ul>
    <p><strong>DNS</strong> - обращаться к серверу не по IP, а по нормальному имени. До появления DNS всё, что у нас было —
    это файлик /etc/hosts. Он и сейчас часто используется. Иногда (на самом деле, очень часто) необходимо сделать так,
    как будто и клиент и сервер находятся в одной частной сети. VPN - Virtual Private Network Например, когда все
    сервисы компании находятся в закрытой сети, доступной только в офисе, и нужно дать сотрудникам удалённый доступ. Или
    когда у компании несколько офисов или дата центров, которые нужно соединить друг с другом так, чтобы по-прежнему не
    открывать всю сеть всему интернету.</p>

    <h2>4. Транспортный уровень &nbsp;</h2>

<p> Предоставлен для доставки данных. Просто предоставляет механизм передачи, какие данные - неважно. Блоки данных он
    разделяет &nbsp;на фрагменты, размеры которых зависят от протокола.
</p>
<p> Точка-точка. Пример: <a href="https://ru.wikipedia.org/wiki/TCP">TCP</a>,
    <a href="https://ru.wikipedia.org/wiki/UDP">UDP</a>. <br/>
    <br/>
</p>
<p><strong>TCP</strong> (transmission control protocol) - протокол, транспортного уровня, обеспечивающий надёжную
    доставку данных,&nbsp;в которых совместно используются протоколы TCP и <a href="https://ru.wikipedia.org/wiki/IP">IP</a> называются сетями <a  href="https://ru.wikipedia.org/wiki/TCP/IP">TCP/IP</a>.<br/>
    UDP
    (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a>
    User Datagram Protocol — протокол пользовательских <a   href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%B9%D1%82%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0">датаграмм</a>)
    - быстрее, потому что не создает дополнительной нагрузки на получение пакета. <br/>
    <br/>
    Основные характеристики TCP: <br/>
    <ul>
        <li>Установка соединения (сессии)&nbsp;</li>
        <li>Надёжная доставка (автоматическая пересылка потерявшихся сегментов)&nbsp;</li>
        <li>Доставка сегментов и сборка их в том же порядке, в каком происходило сегментирование (так как разные
            сегменты запаковываются в индивидуальные пакеты, которые теоретически могли идти по сети разными маршрутами,
            в итоге сегменты могут прийти не в том порядке, в котором отправлялись. В этом случае TCP, тем не менее,
            соберёт их в правильном порядке).&nbsp;</li>
        <li>Контроль потока (TCP может уменьшать скорость передачи информации в случае, если получатель не справляется с
            приёмом по причине ограниченности ресурсов).
        </li>
    </ul>
</p>
<p> Все эти характеристики позволяют снять множество задач с программиста, разрабатывающего протокол уровня
    приложений: ему не надо заботиться о надёжной доставке, о порядке обработки сегментов, об установке соединений. Тем
    не менее, благодаря этим функциям, TCP замедляет передачу сообщения. Часто приложению нужна просто быстрая доставка
    и нет никаких требований по надёжности. Тут на помощь приходит протокол UDP. Его особенности — противоположность
    особенностям TCP. UDP отличается:</p>
    <ol>
        <li>Отсутствием сессий.&nbsp;</li>
        <li>Ненадёжной доставкой.&nbsp;</li>
        <li>Отсутствием упорядочивания сегментов&nbsp;</li>
        <li>Отсутствием контроля за скоростью передачи&nbsp;</li>
        <li>Максимально возможной скоростью передачи данных за счёт всего вышеперечисленного.</li>
    </ol>

   <p> UDP используется там, где важна скорость.&nbsp;</p>
<p> Давайте рассмотрим два примера: <br/>
    <ol>
        <li>Человек загружает страничку, или, что более интересно, архив файла с сайта. Если потеряется хоть один
            сегмент, то скачивание архива не имеет смысла, так как он не распакуется. В этом случае конечно используется
            TCP.&nbsp;</li>
        <li>Человек разговаривает по IP-телефону. Каждый кусок речевой информации должен приходить ровно в то время,
            когда его ожидают услышать (то есть между предыдущим и последующим), тут важно взаимодействие именно в
            реальном времени. В этой ситуации используется UDP.
        </li>
    </ol>
</p>
<h2> 5. Сеансовый уровень</h2>
<p> Отвечает за поддержание
    <a href="https://ru.wikipedia.org/w/index.php?title=%D0%A1%D0%B5%D0%B0%D0%BD%D1%81_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)&amp;action=edit&amp;redlink=1">сеанса связи</a>, позволяя приложениям взаимодействовать между собой длительное время. Уровень управляет
    созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных и
    поддержанием сеанса в периоды неактивности приложений.
</p>
<p> Основной протокол - NetBIOS (Network Basic Input/Output System) <br/>
    <br/>
    Сеансовый уровень отвечает за организацию сеансов обмена данными между оконечными машинами. Протоколы сеансового
    уровня обычно являются составной частью протоколов трех верхних уровней модели.<br/>
    <br/>
    На сеансовом уровне определяется, какой будет передача между двумя прикладными процессами:<br/>
</p>
    <ol>
        <li>полудуплексной (процессы будут передавать и принимать данные по очереди);&nbsp;</li>
        <li>дуплексной (процессы будут передавать данные, и принимать их одновременно).</li>
    </ol>
    <br/>
    <h2>6. Представительский уровень</h2>

<p> Отвечает за преобразование протоколов и кодирование/декодирование данных. Запросы приложений, полученные с уровня
    приложений, он преобразует в формат для передачи по сети, а полученные из сети данные преобразует в формат, понятный
    приложениям. На этом уровне может осуществляться сжатие/распаковка или кодирование/декодирование данных, а также
    перенаправление запросов другому сетевому ресурсу, если они не могут быть обработаны локально.Представительный
    уровень выполняет следующие основные функции:
</p>
<ol>
    <li>Генерация запросов на установление сеансов взаимодействия прикладных процессов.</li>
    <li>Согласование представления данных между прикладными процессами.</li>
    <li>Реализация форм представления данных.</li>
    <li>Представление графического материала (чертежей, рисунков, схем).</li>
    <li>Засекречивание данных.</li>
    <li>Передача запросов на прекращение сеансов.</li>
</ol>
<p>Протоколы уровня представления данных обычно являются составной частью протоколов трех верхних уровней модели.</p>

    <h2> 7. Прикладной уровень</h2>
        <p>
    Обеспечивает взаимодействие сети и пользователя. Уровень разрешает приложениям пользователя иметь доступ к сетевым
    службам, таким, как обработчик запросов к базам данных, доступ к файлам, пересылке электронной почты. Также отвечает
    за передачу служебной информации, предоставляет приложениям информацию об ошибках и формирует запросы к уровню
    представления.
</p>
<p> Пример: <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP</a>, <a href="https://ru.wikipedia.org/wiki/Post_Office_Protocol">POP3</a>, <a href="https://ru.wikipedia.org/wiki/SMTP">SMTP</a>, FTP
</p>

<p> <b>HTTP</b>(HyperText Transfer Protocol — «протокол передачи гипертекста»). Изначально — в виде гипертекстовых документов
    в формате «<a href="https://ru.wikipedia.org/wiki/HTML">HTML</a>», в настоящий момент используется для передачи
    произвольных данных. Основой HTTP является технология «клиент-сервер»
</p>
<ul>
    <li>Потребителей (клиентов), которые инициируют соединение и посылают запрос;</li>
    <li>Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и
        возвращают обратно сообщение с результатом.
    </li>
</ul>
<p>Фактически клиент и сервер — это программное обеспечение. Обычно эти программы расположены на разных вычислительных машинах и взаимодействуют между собой через компьютерную сеть посредством сетевых протоколов, но их можно расположить также и на одной машине.на самом сервере, содержащим базу данных, функционирует некоторое программное обеспечение, которое называется "Сервером баз данных" или "Сервером БД".</p>

<p>
    Также, существуют и другие виды. Например, файл-сервер или терминал сервер.
</p>
<p><br/>
    Файл-сервер - В данном случае сервер, на котором лежит база данных, является исключительно хранилищем и не обладает
    каким-либо функционалом, позволяющим производить математические и/или логические вычисления.
</p>
<p><br/>
    Терминал-сервер - сервер предоставляет пользователю свой Рабочий стол, свои программы и т.д. Т.е. получается, что
    фактически пользователь работает за другим компьютером, физически удаленным от него, получая по сети только
    изображение Рабочего стола с запущенными программами с заданной частотой.
</p>
<p><br/>
</p>
<p> Сам по себе протокол HTTP не предполагает использование шифрования для передачи информации. Тем не менее, для HTTP
    есть распространенное расширение, которое реализует упаковку передаваемых данных в криптографический протокол SSL
    или TLS.<br/>
    <br/>
</p>
<p> Название этого расширения — <strong>HTTPS</strong> (HyperText Transfer Protocol Secure). Для HTTPS-соединений
    обычно используется TCP-порт 443. HTTPS широко используется для защиты информации от перехвата.
</p>

<p> HTTP 1.1 и 2.0</p>
<p><a href="https://http2.github.io/">Протокол HTTP/2</a> существенно ускоряет открытие сайтов за счет следующих
    особенностей:
</p>
<ol>
    <li>соединения: несколько запросов могут быть отправлены через одно TCP-соединение, и ответы могут быть получены в
        любом порядке. Отпадает необходимость держать несколько TCP-соединений; (HTTP - одно соединение - один ресурс)
    </li>
    <li>приоритеты потоков: клиент может задавать серверу приоритеты — какого типа ресурсы для него более важны, чем
        другие; (HTTP - 6 соединений в браузере на один домен)
    </li>
    <li>сжатие заголовка: размер заголовка HTTP может быть сокращен; (HTTP - заголовки не сжимаются)</li>
    <li>push-отправка данных со стороны сервера: сервер может отправлять клиенту данные, которые тот еще не запрашивал,
        например, на основании данных о том, какую следующую страницу открывают пользователи.
    </li>
</ol>
<br/>
<p> SPDY (читается как «speedy», «спиди») — <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D1%8B_%D0%BF%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F">протокол
    прикладного уровня</a> для передачи веб-контента. Протокол разработан корпорацией
    <a href="https://ru.wikipedia.org/wiki/Google_(%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D1%8F)">Google</a>. По
    замыслу разработчиков, данный протокол позиционируется как замена некоторых частей <a href="https://ru.wikipedia.org/wiki/IP">протокола</a> <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP</a>
    — таких, как управление соединениями и форматы передачи данных.
</p>
